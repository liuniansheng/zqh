归并排序
-------

把数组从中间分开
```
-------------------------------------------
|begin           mid|mid+1             end|
-------------------------------------------
i                    j
```
假设左右2个子数组L，R 都是有序的

那么从L拿出一个元素L[0]，同理R拿出R[0]

将小的元素 放入 新数组 ，假设 L[0] 小
```python
A = [ L[0] ]
```
然后L[1] 和 R[0]  比较， 假设 L[1] 小
```python
A = [ L[0], L[1] ]
```
然后 L[2] 和 R[0], 假设 R[0] 小

```python
A = [ L[0], L[1], R[0] ]
```

如此反复，如果其中一个子数组完成后， 那么另外的子数组 直接加入 A 即可

最终得到的A是 L R 的并集，并且是有序的。

上面的步骤成为2个数组的合并,我们用单函数`MERGE(L,R)`表示`合并`并`排序`两个子数组L，R。

MERGE 返回一个有序数组A ， A 是 L R 的并集。 

通过MERGE 实现归并排序
----------

那么对于一个无序数组 A , 如何排序？

我们可以先将A 等分为2个子数组 L， R

如果L 和 R 是有序的，可以用`MERGE(L,R)`完成对A的排序，

如果想让 L 有序，那么需要`对L排序`， 这个问题 和 `如何对A排序` 是一样的，

我们同样的可以将L也 等分为两个子数组，  LL  和 RR

那么通过 用`MERGE(LL,RR)` L就是有序的了。 这个问题又变成了 如何让LL或者RR有序

于是我们可以发现这是一个递归的过程。不断的等分后，最后总会出现这样的情形

子数组 X 只有2个元素 a ，b  ,那么X等分后 得到2个子数组 [a], [b], 我们发现

数组 [a] 不能再继续等分了， 只有一个元素说明它已经是有序的了，同理[b] 也是有序的，

所以 `MERGE([a], [b])` 得到的X ， X 必然是有序的

```
  XY= [ a,b, c,d]

X = [ a, b]     Y = [c, d]

```
X是有序的，  `MERGE([c], [d])` 得到的Y 也是有序的， 那么  `MERGE(X, Y)` 得到的 数组 XY 也是有序的.

最终通过一系列的MERGE操作， 得到数组A 就是有序的了。



归并排序的另一种思路
-----------

上面的方式是 通过不断的分割 数组A， 直到分割到只有1个元素的 数组，再对它们进行合并。

那么我们可不可以简化这个过程，不去分割A， 直接 找到 2 个 元素， 把它们当作 2个子数组，直接合并。

例如 数组 
```
A = { 3,7,  2,6,  9,0, -4 }
```
直接对3 7 合并 MERGE(3,7), 直接对 2 6 合并 MERGE(2,6)....

那么 A 变为
```
MERGE(3,7) MERGE(2,6) MERGE(9,0)  -4 

A = { [3,7] ， [2,6] ， [0,9] ， [-4] }
```
A 里面的元素 都是`有序的`子数组,所以
```
MERGE([3,7], [2,6]) ,  MERGE([0,9],  [-4])

A = { [2,3,6,7] , [-4,0,9]}
```
最后 MERGE ([2,3,6,7] , [-4,0,9])

A 排序完成。

赵勋 易有涛 老师请完成归并排序的2种方式的实现
-----


快速排序
--------

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，该方法的基本思想是：

1．先从数列中取出一个数作为基准数。

2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

3．再对左右区间重复第二步，直到各区间只有一个数。


例如 每次选数组的第一个元素 作为基准数 p
```
72 ,6 ,57 ,88 ,60 ,42 ,83 ,73 ,48 ,85
p = 72
```
遍历数组元素 并和p 比较
```
6,57,60,42,48    p=72    88,83,85
p=6                      p=88
```
左右两边继续
```
[6,57,60,42,48]    p=72    [88,83,85]

null p=6   [57,60,42,48]       p=72     [83,85] p=88 null
           p=57                         p=83
           [42,48] p=57 [60]            null p=83 [85]
           p=42
           null p=42 [48]    
```
最后一步时 每个子区间只有一个数

72 的左边是   [...]    6  [...]  ,     72 的右边边是   [...]    88  [...] 
```
A = ( [...]    6  [...] )   72   ( [...]    88  [...] )
其中
 [...]    6  [...] =  null  ，6  ，  ([...] 57 [...])
                  =  6, ([...] 57 [...])   
                  
 [...] 57 [...]  =   ([...] 42 [...]) , 57,  (60)
                 =  ( null, 42, 48), 57, 60
                 = 42,48,57,60
所以                 
   [...]    6  [...] = 6, ([...] 57 [...])   = 6,42,48,57,60 
   
   
   A = 6,42,48,57,60,  72 , ([...]    88  [...] )
```
后面就不写了

增祥荣 宋国陪 老师请完成 快速排序的实现
----------------



提交代码 请先加入 nxintech
大家的可以把github 账号发到我的qq :86271700

